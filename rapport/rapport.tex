% Edgar Fournival <contact@edgar-fournival.fr>

\documentclass[12pt,a4paper]{article}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}

\usepackage[francais]{babel}

\usepackage{ifxetex}

\ifxetex
	\usepackage{fontspec}
\else
	\usepackage[T1]{fontenc}
	\usepackage[utf8]{inputenc}
\fi

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{eurosym}
\usepackage{mathtools}

\usepackage[noend]{algorithmic}
\renewcommand{\algorithmicif}{\textbf{si}}
\renewcommand{\algorithmicthen}{\textbf{alors}}
\renewcommand{\algorithmicfor}{\textbf{pour}}
\renewcommand{\algorithmicdo}{\textbf{faire}}

\usepackage{enumitem}
\usepackage{adjustbox}
\usepackage[hidelinks]{hyperref}

\setlength\parindent{0pt}
\setlength\parskip{0.25em}

\let\emptyset\varnothing
\let\leq\leqslant
\let\geq\geqslant

\begin{document}

\section*{Introduction}

\subsection*{Mission}
Ce TER consiste en l'exploration de l'arbre de semigroupes numériques dans le but de compter le nombre de combinaisons possibles jusqu'à une profondeur donnée.

L'exploration consiste en un algorithme DFS (\emph{depth first search}) qui, à partir d'un semigroupe donné, génère tous les semigroupes fils induits par la suppression d'un nombre générateur.

Florent Hivert et Jean Fromentin ont proposé un algorithme optimisé pour résoudre ce problème et ont réussi à calculer le nombre de semigroupes jusqu'à la profondeur 67, ce qui a pris 18 jours.

Cela fait suite aux calculs effectués par Maria Bras-Amorós à l'aide d'un algorithme DFS performant mais non-optimisé qu'on appellera par la suite ``algorithme naïf''.

L'algorithme optimisé est implémenté en \texttt{C++} et fait appel à de nombreuses techniques pour réduire le temps de calcul d'une solution engendrée à quelques dizaines de cycles processeur : vectorisation, parallélisation à l'aide de \texttt{Cilk++}, dérécursivation de l'exploration, optimisations des boucles et des accès mémoire ainsi qu'un choix rigoureux des types de données.

La principale limitation de cet algorithme est qu'il n'est pas possible de le distribuer facilement sur plusieurs machines. En effet, l'arbre d'exploration n'est pas équilibré et des problèmes de charge se posent rapidement (une seule machine fait tout le travail).

Une solution possible à ce déséquilibrage serait la mise en place d'un système de vol de tâche.

Le but de mon TER est donc de fournir une solution pour le calcul du nombre de semigroupes qui est performante, parallélisée et distribuée. L'objectif à terme sera de lancer le calcul final sur un cluster de machines performantes.

\subsection*{Problème posé}
L'exploration de l'arbre d'un semigroupe numérique n'est pas triviale et est apparentée au problème de Frobenius.

Le mathématicien Georg Frobenius s'est posé la question suivante : quel est le montant maximal que l'on peut pas rendre en fonction de pièces de monnaie données ?

Ce montant se nomme ``nombre de Frobenius'' et est plus formellement décrit par le plus grand entier qu'il est impossible de calculer à partir de coefficients donnés.

On peut aussi visualiser ce problème en considérant les scores au Rugby : quels sont les scores que l'on ne peut pas obtenir avec le but (3 points), l'essai (5 points) et l'essai transformé (7 points) ?

La résolution des scores au Rugby est simple, on ne peut pas avoir 1, 2 ou 4 points; tous les autres scores sont possibles. En effet, il est aisé de calculer le nombre de Frobenius (ici, 4) pour $n \leq 3$ où $n$ est le nombre d'entiers possibles pour la combinaison. Ici, $n = 3$ pour $\{3,5,7\}$.

\section*{Déroulement}

\subsection*{Jeudi 12 janvier 2017}
Installation au LRI, explications :
\begin{itemize}
	\item	parcours de l'arbre de semi-groupes numériques

	\item	structures de données utilisées, notamment dans \texttt{NumericMonoid}

	\item	algorithme ``naïf'' : tableau de booléens (le nombre est-il dans le semi-groupe ?) de taille $B =$ genre, soit la profondeur dans l'arbre et le nombre de trous
			\begin{algorithmic}
				\FOR {$g \text{ de dernierEnlevé + 1 à } B$}
					\IF{$T[g]$}
						\FOR {$i \text{ de } 1 \text{ à } \lfloor \frac{g}{2} \rfloor$}
							\IF{$T[i]$ et $T[g-i]$}
								\STATE $g$ est un nombre de décomposition
							\ENDIF
						\ENDFOR
					\ENDIF
				\ENDFOR
			\end{algorithmic}

	\item	algorithme optimisé facilitant la vectorisation : tableau d'entiers modélisant le nombre de paires ($i, j \in$ SN tel que $i + j = g$ et $i \leq j$), tous les nombres avec exactement une paire sont des générateurs
\end{itemize}

\subsection*{Autonomie}
\begin{itemize}
	\item	première implémentation de l'algorithme naïf; difficultés : initialisation, confusion décomposition/générateur
	\item	première implémentation de l'algorithme optimisé
	\item	organisation du dépôt Git
\end{itemize}

\subsection*{Lundi 16 janvier 2017}
\begin{itemize}
	\item	mise au point et correction de l'algorithme naïf
	\item	débogage et tests
\end{itemize}

\subsection*{Autonomie}
\begin{itemize}
	\item	mise en place de tests unitaires
	\item	amélioration de l'algorithme naïf; difficulté : les tests unitaires sur des semigroupes connus passent, mais le résultat final (nombre de semigroupes calculés, par genre) n'est pas bon
	\item	correction de l'algorithme optimisé : il fonctionne
	\item	correction de l'algorithme naïf en rajoutant l'attribut \texttt{m}
	\item	parallélisation à l'aide d'un verrou partagé en lecture/écriture sur la pile (\texttt{sync.RWMutex}) et d'une incrémentation atomique sur les cellules du tableau de résultat (packages \texttt{sync/atomic} et \texttt{unsafe})
	\item	difficultés : critère d'arrêt pour un genre donné, profiler le code car la charge processeur reste faible (verrous ?), types de données, stratégies de parallélisation
\end{itemize}

\subsection*{Jeudi 26 janvier 2017}
\begin{itemize}
	\item	présentation du profiling avec la commande \texttt{perf}, elle est effective au niveau hardware donc ne dégrade pas les performances; permet d'associer code machine/symboles de débogage au temps relatif passé par le processeur; commandes \texttt{perf record}, \texttt{perf report} et \texttt{sudo perf top} pour du temps réel
	\item	pour tester \texttt{NumericMonoid}, on ferra attention à se positionner dans le répertoire \texttt{src/Cilk++}
	\item	il faut vérifier la bonne parallélisation en testant différents nombres de threads (modification de \texttt{runtime.GOMAXPROCS}); une bonne parallélisation donnera le résultat deux fois plus rapidement si on double le nombre de threads (jusqu'au nombre de c\oe{}urs, mais attention à l'HyperThreading : tester avec 2 fois le nombre de c\oe{}urs physiques); seul 5 à 10\% du temps de calcul total est destiné à la communication/synchronisation
	\item	pour remplacer l'utilisation de \texttt{sync/atomic}, on peut utiliser un stockage local au thread; implémenté dans Sage en Python; en Go, on pourra utiliser des \emph{channels} (\emph{pipes} en Python)
	\item	pour s'arrêter lorsque les calculs sont parallélisés : compter le nombre de processus actifs (entre le pop de la pile et après les push); on a fini lorsque la pile est vide et qu'il n'y a aucun processus actifs; fait appel à \texttt{sync/atomic}
\end{itemize}


\section*{Résultats}

\section*{Conclusion}

\end{document}
